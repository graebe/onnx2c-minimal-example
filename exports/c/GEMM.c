// This file is computer-generated by onnx2c 
// (TODO: add creating command line here)
// (TODO: print creation date here )

// ONNX model:
// produced by pytorch, version 2.0.1
// ONNX IR version: 14
// Model documentation: 
/*

*/

#include <float.h>
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#define MAX(X,Y) ( X > Y ? X : Y)
#define MIN(X,Y) ( X < Y ? X : Y)
#define CLIP(X,L) ( MAX(MIN(X,L), -L) )

static const float tensor_l1_weight[3][5] = 
{
  {1.0000000000000000000f, 2.0000000000000000000f, 3.0000000000000000000f, 4.0000000000000000000f, 5.0000000000000000000f},
  {6.0000000000000000000f, 7.0000000000000000000f, 8.0000000000000000000f, 9.0000000000000000000f, 10.000000000000000000f},
  {11.000000000000000000f, 12.000000000000000000f, 13.000000000000000000f, 14.000000000000000000f, 15.000000000000000000f}
};
static const float tensor_l1_bias[3] = 
{10000.000000000000000f, 20000.000000000000000f, 30000.000000000000000f};

static inline void node__l1_Gemm( const float tensor_input[1][5], const float tensor_l1_weight[3][5], const float tensor_l1_bias[3], float tensor_output[1][3] )
{
	/* Gemm */
	/* alpha   = 1.0000000000000000000
	   beta    = 1.0000000000000000000
	   transA  = 0
	   transB  = 1
	 */
	const int M = 1;
	const int K = 5;
	const int N = 3;
	float (*A)[5]  = (float(*)[5])tensor_input;
	float (*Y)[3]  = (float(*)[3])tensor_output;
	float alpha = 1.0000000000000000000;
	float beta = 1.0000000000000000000;
	float (*C)[3]  = (float(*)[3])tensor_l1_bias;
	for( uint32_t r=0; r<M; r++ )
		for( uint32_t c=0; c<N; c++ ) {
			float ABrc = 0;
			for( uint32_t i=0; i<K; i++ ) {
				float B = tensor_l1_weight[c][i];
				ABrc += A[r][i] * B;
			}
			float tmp = ABrc * alpha;
			tmp += C[0][c] * beta;
			Y[r][c] = tmp;
	}
}


void entry(const float tensor_input[1][5], float tensor_output[1][3]) {
	node__l1_Gemm( tensor_input, tensor_l1_weight, tensor_l1_bias, tensor_output);
}
